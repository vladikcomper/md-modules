
# MD-Shell

MD-Shell is a stand-alone easy to use "assembly header" running small programs as Sega Mega-Drive ROMs.

It includes initialization code, error handler and all debugger macros (e.g. `Console.Write`, `Console.Run` etc).

## Simple hello-world

Once you include `MDShell.asm` header, you can write a simple console program in 3 lines of code:

```
	include "MDShell.asm"

Main:
	Console.WriteLine "Hello, world!"
	rts
```

Each program should define "Main:" as an entry point.

Anywhere in your code you can access `Console` object and call `RaiseError`.


## Supported assemblers

MD-Shell uses CBundle utility to produce bundles that target different assemblers. This process simply combines various code fragments found in this directory (and generated by MD-Shell's build script) into a single file, where CBundle acts similarly to a pre-processor.

The following bundles are currently provided:

* `bundle-asm68k` - a complete header with blob targetting the _ASM68K assembler_;
* `bundle-as` - a complete header with blob targetting the _AS Macroassembler_ (v.1.42 Bld 55 and above);
* `headless` - blob-only version, that should be compatible with any ASM68K assembler; it's mostly useless since macros aren't included.

> [!WARNING]
>
> The AS Macroassembler version has limited support for some features!


## Macros reference

### `assert`

**Syntax:**

        assert[.b|.w|.l]    src_operand, condition[, dest_operand]

**Description:**

Asserts that the given condition is true. Raises "assertion failed" exception otherwise with the text of a failed condition.

Think of assertions as pseudo-instructions for debugging purposes that: test the given operands (`src_operand` and `dest_operand`), continue program execution if `condition` is true, raise an exception with `RaiseError` otherwise. Consider the following example:

        assert.w d0, lt, #64       ; assert than `d0` register is less than 64

This code is equivalent to the following:

        cmp.w    #64, d0
        blt.s    ok
        RaiseError "Assertion failed:%<endl>d0 lt #64"
    ok:

Assertions also have a single-operand form for simplicity:

        assert.b MyRAMFlag, ne     ; assert that `MyRAMFlag` is not equal to zero

Which is the same as using `tst` instead of `cmp` in the equivalent code:

        tst.b    MyRAMFlag
        bne.s    ok
        RaiseError "Assertion failed:%<endl>MyRAMFlag ne"
    ok:

Operands in assertions can use all the addressing modes that `tst` and `cmp` instructions support:

        assert.b (a0), eq            ; assert that the byte at `(a0)` is zero
        assert.w d2, lo, 2(a3)       ; assert that `d2` register is lower than `2(a3)`
        assert.l MyData(pc,d0), mi   ; assert that the longword at `MyData(pc,d0)` is negative

**Arguments:**

* `src_operand` - source operand.
* `condition` - condition to test (e.g. `eq`, `ne`, `mi`, `pl`, `cs`, `cc` etc).
* `dest_operand` (optional) - destination operand; if present, `src_operand` is compared to `dest_operand`, otherwise a single `src_operand` is tested.


### `RaiseError`

**Syntax:**

        RaiseError text[, handler]

**Description:**

Displays an error screen with the specified message. Program execution is then halted.

**Arguments:**

* `text` - a formatted string representing an error message, for example: `"Object at address %<.w a0 hex> crashed"`; displays in error screen's header.
* `handler` (optional) - label of the console program (subroutine) used to print error screen body; if omitted, standard error handler is used.


### `Console.Write` and `Console.WriteLine`

**Syntax:**

        Console.Write text
        Console.WriteLine text

**Description:**

Writes a _formatted string_ in the console.

`.WriteLine` variant automatically adds a newline at the end of the string.

`.Write` variant doesn't add newline, so the next write will append to the same line. However, you can use `%<endl>` token in string to add newlines manually, for instance:

        Console.Write "Ready...%<endl>Set...%<endl>Go!"

**Arguments:**

* `text` - a formatted string to write in the console.


### `Console.SetXY`

**Syntax:**

        Console.SetXY  x, y

**Description:**

Sets write position to the specified position of screen (in tiles), for example:

        Console.SetXY #1, #2

Console size is 40 x 28 tiles.

To set the leftmost position, use:

        Console.SetXY #0, #0

Since `x` and `y` are _operands_, all M68K addressing modes may be used to pass these parameters, for instance:

        Console.SetXY d0, PositionData+1(pc,d1)  ; read X from d0, read Y from PositionData+1(pc,d1)

**Arguments:**

* `x` - a word-sized operand (register, memory or immediate value), represents x position in tiles
* `y` - a word-sized operand (register, memory or immediate value), represents y position in tiles


### `Console.BreakLine`

**Syntax:**

        Console.BreakLine

**Description:**

Adds a newline.

**Alternative:**

        Console.Write "%<endl>"


### `Console.Clear`

**Syntax:**

        Console.Clear

**Description:**

Clears the entire console screen and resets the cursor back to the top-left corner (coordinate `#0, #0`).


### `Console.Sleep`

**Syntax:**

        Console.Sleep  frames

**Description:**

Pauses program execution for the given number of frames. The following example pauses for 60 frames (1 second in NTSC mode):

        Console.Sleep  #60

Since `frames` argument is an operand, it can use all M68K addressing mode, not just _immediate value_ (i.e. `#<Number>`), for instance:

        Console.Sleep  d0   ; sleep for the number of frames specified in the d0 register

**Arguments:**

* `frames` - a word-sized operand (register, memory or immediate value), number of frames to sleep.


### `Console.Pause`

**Syntax:**

        Console.Pause

**Description:**

Pauses console program execution until A, B, C or Start button is pressed on the joypad.


## Formatted string reference

Formatted strings may include flags or formatted values, which are encapsulated in `%<...>` tokens, for example:

        Console.Write "d0 equals to %<.b d0 hex|signed>, and... %<endl>d1 is %<.w d1>"

**Supported tokens**

    %<endl> - end of line flag, adds a newline;
    %<cr> - carriage return, jump to the beginning of the same line;
    %<pal0> - use palette line #0;
    %<pal1> - use palette line #1;
    %<pal2> - use palette line #2;
    %<pal3> - use palette line #3;
    %<setw,X> - set line width: number of characters before automatic newline
        by default, X=40 in console-only mode, X=38 on error screens
        WARNING! In AS version, you have to write "%<setw>%<X>" due to macros limitations
    %<setx,X> - set X-position of the next character on the line;
        WARNING! In AS version, you have to write "%<setx>%<X>" due to macros limitations

Flags can be merged into a single token, for example: instead of `"%<endl>%<setx,2>%<pal0>"` you can just write `"%<endl,setx,2,pal0>"`.

> [!WARNING]
>
> Merging flags is only supported in ASM68K version.

**Formatted values tokens:**

`%<type operand[ format]>`

    type - must be .b, .w or .l
    operand - source register or memory address, supports the same addressing modes as MOVE command
    format (optional) - specifies value formatter and it's arguments, if needed. Default format is hex.
        hex - display as hexadecimal number
        dec - display as decimal number
        bin - display as binary number
            hex|signed, dec|signed, bin|signed -- treat value as signed number (additionally displays + or - before the number depending on its sign)
        sym - treat value as offset, decode into symbol+displacement
        str - treat value as offset, display C-string pointered by it

**Examples:**

Displaying numbers:

```asm
    move.w   #$F211, d0
    Console.WriteLine "%<.b d0>"              ; prints "11"
    Console.WriteLine "%<.b d0 dec>"          ; prints "17"
    Console.WriteLine "%<.w d0>"              ; prints "F211"
    Console.WriteLine "%<.w d0 hex|signed>"   ; prints "-0DEF"
    Console.WriteLine "%<.b d0 hex|signed>"   ; prints "+11"
    rts
```

Advanced usage:

```asm
   lea     SomeData, a0
   moveq   #1, d0
 
   Console.WriteLine "a0 = %<.l a0 sym>"       ; prints "a0 = somedata"
   Console.WriteLine "%<.b SomeData(pc,d0)>"   ; prints "19"
   addq.w  #1, d0
   Console.WriteLine "%<.b SomeData(pc,d0)>"   ; prints "B3"

   Console.WriteLine "%<.l #SomeString str>"   ; prints "Apples!"

   rts
 
SomeData:
   dc.b   $AE, $19, $B3, $10
 
SomeString:
   dc.b   "Apples!", 0
```

> [!WARNING]
>
> Trying to display the value of register SP (also known as A7) or address using it (e.g. %<.l -4(sp)>) leads to unexpected results. This is because formatted strings arguments are stored on stack at run-time, so stack pointer's value is different by the time it's requested.
> 
> Do not try to print SP directly, the results are unreliable.

> [!WARNING]
> AS version doesn't support some of the addressing modes in formatted strings. Only the following modes are supported:
>
> - __Absolute__ (`MyAddress`, `$FF0000`), but `(xxx).w`/`(xxx).l` syntax is not recognized;
> - __Immediate__ (`#1234`, `#SomeValue`);
> - __Register direct__ (`d0`-`a6`);
> - __Address register indirect__ (`(a0)`-`(a6)`);
> - __Address register indirect with displacement__ (e.g. `1(a0)`, `-$20(a3)`, `myval(a1)` etc);
>
> ASM68K version supports all the standard addressing modes that M68K provides.
